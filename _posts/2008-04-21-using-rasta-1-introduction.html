---
layout: post
title: 'Using Rasta #1 - An introduction'
date: '2008-04-21T14:56:00.001+01:00'
author: Sebastien Lambla
tags: 
modified_time: '2008-04-21T14:56:56.789+01:00'
blogger_id: tag:blogger.com,1999:blog-4015568221071268916.post-8770271844613270465
blogger_orig_url: http://serialseb.blogspot.com/2008/04/using-rasta-1-introduction.html
---

<p>Rasta has many meanings, but for the purpose of this blog, it is the <strong>R</strong>EST <strong>A</strong>rchitecture <strong>S</strong>olution <strong>T</strong>argeting <strong>A</strong>sp.net. I've written this framework for one of my clients, and I'm in the process of trying to get the rights to open-source it and deliver it to the world. But as many things, it takes a lot of time.</p>  <p>That said, I've been wanting to blog about it since I started working on it, so now is as good a time as ever to start showing some bits on how to use it. It will let my beloved readers criticize the way the API is built, which will let me involve it for the better, and will also serve as a reference point for my client's employees to have some sort of reference on how the framework works.</p>  <p>Rasta, in essence, is a framework that lets you think about your site in terms of resources, how they are accessed, and how representations of such resources get served to clients. Let's compare this approach with other approaches we've seen over the years.</p>  <h4>WebFroms</h4>  <p>In this model, your Url is bound to your page. Because of the post-back model, any interaction with the system is done as units within the webform. <a href="http://example.org/Customer.aspx">http://example.org/Customer.aspx</a> provides a view of your customer, but is also where data gets posted back. The posting of the data itself can be either about a customer, or about a button, or about an event one of the webcontrols can trigger. It can be a bit of anything.</p>  <p>This has a couple of very bad consequences. Only the asp.net framework can post data to /customer.aspx, because it's the only one knowing the format. This makes testing webforms terribly difficult, and patterns like MVP only solve the problem at the unit-testing code level, leaving a lot of code non-testable. It also makes integrating with other systems more painful than it should be. And it doesn't leverage hypertext in any way, because state is transferred across postbacks through either the session or the viewstate.</p>  <p>In this model, the resource is the page, and does many things. It's completely unrestful.</p>  <h4>The MVC model</h4>  <p>A lot of noise is being made about the new asp.net MVC framework. MVC as a pattern solves some of the issues introduced by webforms. Your Url is bound to a controller that receives the request, act upon it and send you to a view based on the result of the operation. This solves the unit-testing issue. To a certain extent, it also solves partially the integration issue, as your controller can act upon the http operations (GET PUT POST DELETE etc...).</p>  <p>That said, your Url is bound to a controller's action, so you would end up most of the time with a url looking like <a href="http://example.org/Customer/GetCustomer">http://example.org/Customer/GetCustomer</a>. You're mapping one web action to an operation. While you can override that, it's not the default. Another issue that makes it unrestful is the lack of leverage of hypertext, as links are not used for anything meaningful unless you implement that yourself.</p>  <p>In this model, the resource is the controller, and does quite a few things. It's up to you to define the semantics. It's quite unrestful.</p>  <h4>The WCF Rest model</h4>  <p>WCF in 3.5 has some support for something quite similar to the model provided by MVC. Your WCF service can be mapped to a specific Url and encoding (xml and json), and it will support a Get and a notion that team came up, an invoke. The rationale being that there was not that much of a different meaning between POST/PUT to justify mapping them differently, and that they all end up invoking a service.</p>  <p>This is a service-centric view that maps very poorly with the web. You're tying your Url to a service operation, and limit your representations to the two kinds provided by WCF. Its great for unit testing, not so much for the web.</p>  <p>I'll also have to question any team having spent that many years providing an abstracted toolkit that lets you not think about the plumbing (although this is a very big white lie) trying to implement a REST architecture which is, by definition, about the plumbing, leveraging Http verbs and hypertext.</p>  <p>In this model, the resource is the service, and does something. It's quite unrestful as well.</p>  <h4>The Ado.net Data Services model</h4>  <p>Formerly called Astoria, ado.net data services is the most restful of the APIs Microsoft is working on.</p>  <p>With Astoria, you map a Url to an entity (ado.net entities), and you interact with those entities based on AtomPub, which is quite restful. That said, it is about exposing your existing entities model on the web, and support for POX / POJson has been dropped from what I understand.</p>  <p>It does leverage hypertext (because AtomPub does), and it does have some content type negotiation. The big issue here is that it doesn't integrate with any of the previous models we've seen, and is yet another API that wants to have the Urls in your web application to itself. It supports data, and data only, so you won't be able to leverage an asp.net MVC page to serve a resource as text/html, and still support application/json for clients that want this format.</p>  <p>In this model, the resource is the entity, and you can do restful things with it. But it only deals with one aspect of developing rest applications, and has poor integration with the other components Microsoft is developing.</p>  <h4>The Rasta model</h4>  <p>Rasta takes a radically different approach. Every Url is mapped to a resource. In other words, <a href="http://example.org/Customer">http://example.org/Customer</a> is mapped to a resource of type CustomerEntity. Each resource type can have many resource handlers that are responsible for acting upon a resource in a certain way. This could mean retrieving a resource, updating it, etc.</p>  <p>When you access a Url to get to a resource (called <em>dereferencing</em>), the first step Rasta is going to take is to try and locate which handler can be used to access the resource, based on the request you made. For example, <a href="http://example.org/Customers/{name}">http://example.org/Customers/{name}</a>&#160; is a Url that would associate a meaning of <em>name </em>with a value to the handler. From that name, the handler would return an instance of the resource (an instance of CustomerEntity). In other words, a handler is responsible for dereferencing a Uri based on a request to get to a resource, and to act upon it if required.</p>  <p>And that's it. The handler is not involved at any point in how the request is processed or how the response is sent to the client. This is the responsibility of the codecs.</p>  <p>A codec is a component that, to simplify, convert a Content-Type sent on the wire to an object and back. In essence, if your handler returns an instance of CustomerEntity, the codec will be able to convert it into an xml stream representation, or whatever wire format the codec supports. Out of the box, the current Rasta svn repository has support for webforms (for html rendering), json and xml, and I have some working code supporting AtomPub, atom, rss and even support for some WebDav, although all this is mostly prototype quality.</p>  <p>In this model, the resource is <em>the resource</em>, and its representations are handled by codecs that are loosely coupled from the resource itself. You could see it as an application of the semantic web, but based on types and objects. In other words, it works and is good enough.</p>  <h4>Conclusion</h4>  <p>Rasta's architecture brings quite a few benefits:</p>  <ul>   <li>Loose coupling between the representation of a resource and the code that does useful stuff with it.</li>    <li>Automatic support for content-type negotiation, letting the client decide what is the best format to receive a resource in.</li>    <li>Resources don't change, but implementation of the handlers can</li>    <li>Adding new content-types is independent from the rest of your code</li>    <li>Adding things like AtomPub becomes very easy</li>    <li>You have only one way to do both your html representation and the computer-friendly ones.</li>    <li>Oh, and it's still compatible with webforms so you can retrofit existing work in the same site</li>    <li>And as a nice to have, it runs on standard .net 2.0.</li> </ul>  <p>There are many other parts to Rasta, but those are the basis of what it is, why it was built, and why I'm so thrilled about it.</p>  <div class="wlWriterSmartContent" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:147b4960-9099-4609-a30b-fbce6cb0613a" style="padding-right: 0px; display: inline; padding-left: 0px; padding-bottom: 0px; margin: 0px; padding-top: 0px">Technorati Tags: <a href="http://technorati.com/tags/semantic%20web" rel="tag">semantic web</a>,<a href="http://technorati.com/tags/rest" rel="tag">rest</a>,<a href="http://technorati.com/tags/rasta" rel="tag">rasta</a>,<a href="http://technorati.com/tags/astoria" rel="tag">astoria</a>,<a href="http://technorati.com/tags/asp.net%20mvc" rel="tag">asp.net mvc</a>,<a href="http://technorati.com/tags/webforms" rel="tag">webforms</a>,<a href="http://technorati.com/tags/c#" rel="tag">c#</a>,<a href="http://technorati.com/tags/.net" rel="tag">.net</a></div>  