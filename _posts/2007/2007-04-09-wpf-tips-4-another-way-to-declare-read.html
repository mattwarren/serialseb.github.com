---
serial: wpf-tips-n-tricks
title: WPF Tips n' Tricks â€“ Another way to declare read-only dependency properties
date: '2007-04-09T18:37:00.001+01:00'
tags: [wpf]
modified_time: '2007-04-18T13:38:12.647+01:00'
blogger_id: tag:blogger.com,1999:blog-4015568221071268916.post-2581487958661715766
comments: true
blogger_orig_url: http://serialseb.blogspot.com/2007/04/wpf-tips-4-another-way-to-declare-read.html
---

<p>Sorry for the hiatus this week-end, I spent a lovely time out of London, disconnected from the online world. Back online (in the train, with WIFI, fantastic, <a href="http://www.gner.co.uk/">check it out</a>).</p><p>Read-only dependency properties (attached or not) are declared by a call to RegisterReadOnly, which returns a DependencyPropertyKey type, which you have to use when setting values. From that object you get a reference to the DependencyPropert object that is used to read values. Let's look at a typical dependency property registration.</p><div style="BACKGROUND: white;font-family:consolas, courier new;font-size:10pt;color:black;"   ><p style="MARGIN: 0px">    <span style="color:blue;">public</span> <span style="color:blue;">class</span> <span style="color:#2b91af;">Div</span> : <span style="color:#2b91af;">Control</span></p><p style="MARGIN: 0px">    {</p><p style="MARGIN: 0px">        <span style="color:blue;">private</span> <span style="color:blue;">static</span> <span style="color:#2b91af;">DependencyProperty</span> LeftProperty;</p><p style="MARGIN: 0px">        <span style="color:blue;">private</span> <span style="color:blue;">static</span> <span style="color:#2b91af;">DependencyPropertyKey</span> LeftPropertyKey;</p><p style="MARGIN: 0px"> </p><p style="MARGIN: 0px">        <span style="color:blue;">static</span> Div()</p><p style="MARGIN: 0px">        {</p><p style="MARGIN: 0px">            <span style="color:#2b91af;">Div</span>.LeftPropertyKey = <span style="color:#2b91af;">DependencyProperty</span>.RegisterReadOnly(</p><p style="MARGIN: 0px">                <span style="color:#a31515;">"Left"</span>, </p><p style="MARGIN: 0px">                <span style="color:blue;">typeof</span>(<span style="color:blue;">double</span>), </p><p style="MARGIN: 0px">                <span style="color:blue;">typeof</span>(<span style="color:#2b91af;">Div</span>), </p><p style="MARGIN: 0px">                <span style="color:blue;">new</span> <span style="color:#2b91af;">FrameworkPropertyMetadata</span>(0d));</p><p style="MARGIN: 0px"> </p><p style="MARGIN: 0px">            <span style="color:#2b91af;">Div</span>.LeftProperty = <span style="color:#2b91af;">Div</span>.LeftPropertyKey.DependencyProperty;</p><p style="MARGIN: 0px">        }</p></div><p>Traditionally, you would then define a property with only a getter. But one of the not so known new features of C# 2.0 is the ability to declare different access modifiers for the getter and the setter of a property. We'll use it to our advantage to declare a property getter but have a private setter using the Key, keeping our object model clean and nifty.</p><div style="FONT-SIZE: 10pt; BACKGROUND: white; COLOR: black; FONT-FAMILY: consolas, courier new"><p style="MARGIN: 0px"> </p><p style="MARGIN: 0px">        <span style="color:blue;">public</span> <span style="color:blue;">double</span> Left</p><p style="MARGIN: 0px">        {</p><p style="MARGIN: 0px">            <span style="color:blue;">get</span> { <span style="color:blue;">return</span> (<span style="color:blue;">double</span>)GetValue(<span style="color:#2b91af;">Div</span>.LeftProperty); }</p><p style="MARGIN: 0px">            <span style="color:blue;">private set</span> { SetValue(<span style="color:#2b91af;">Div</span>.LeftPropertyKey, <span style="color:blue;">value</span>); }</p><p style="MARGIN: 0px">        }</p></div><p>And voila, a nice and clean way to set your read-only properties without calls to SetValue all over the place.</p><p><em>[Edit: Added the private as I forgot it. Thanks for correcting me! ]</em></p>
