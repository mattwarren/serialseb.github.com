---
layout: post
title: How to fix Microsoft’s Two-Tier Service Application Scenario (REST)
date: '2009-01-25T17:49:00.001Z'
author: Sebastien Lambla
tags: 
modified_time: '2009-01-27T08:52:34.589Z'
blogger_id: tag:blogger.com,1999:blog-4015568221071268916.post-8624141050616289006
blogger_orig_url: http://serialseb.blogspot.com/2009/01/how-to-fix-microsofts-two-tier-service.html
---

<p>Microsoft has released a <em>beta</em> version of a guidance talking about <a href="http://www.codeplex.com/AppArch/Wiki/View.aspx?title=App%20Pattern%20-%20Two-Tier%20Service%20Application%20Scenario%20%28REST%29&amp;referringTitle=Application%20Patterns">REST in 2-tier applications</a>. I’ve had many rants about Microsoft’s attitude towards REST and the marketing branding they put on (some teams being much worse than others by arrogantly or unknowingly putting the word REST on the name of their framework).</p>  <p>This entry is no such rant, but an effort to outreach to the authors. The document has issues, but it is my belief that with the right corrections, it could be made accurate.</p>  <h4>Of the importance of patterns</h4>  <p>First thing come first, let’s talk about patterns. Here’s the definition for <em>design pattern</em> from <a href="http://en.wikipedia.org/wiki/Design_pattern">Wikipedia</a>.</p>  <blockquote>   <p>A <b>design pattern</b> [..] is a formal way of documenting a solution to a design problem in a particular field of expertise.</p> </blockquote>  <p>From this, we would expect a pattern that is referenced or talked about to have been <strong>documented</strong>, contextual to a <strong>field of expertise</strong> and used to <strong>solve a design problem</strong>.</p>  <p>Let’s review what patterns are referenced from the document, as it will help us later to analyze the proposed guidance. Whenever a pattern is provided without references, I either assume the first documentation of a pattern as applying, or try, as a reader would, to google it and find what it could mean.</p>  <h5>The router pattern</h5>  <p>I assume this mean the pattern by which a URI is mapped to a component processing the request. My searching has returned <a href="http://www-128.ibm.com/developerworks/library/ws-tip-altdesign3/">an IBM article</a> defining the router pattern as “[…] routing requests to specific pieces of business logic based on some defined criteria”. Anyone trying to search for the router pattern will be inundated with various definitions and hundreds of sub-patterns (content-based router pattern, dynamic router pattern, etc). By failing to reference which variant of a pattern is being included, and where the documentation for such pattern is located, a reader will be none the wiser. And they are, after all, looking for guidance.</p>  <p>The proposed fix: either reference which pattern is being talked about, or document what use you refer to.</p>  <h5>The REST Entity pattern</h5>  <p>A quick google search for “REST Entity pattern” will return only two results, the first one being the proposed guidance, and the second one being a <a href="http://www.sagework.com/whitepapers/Introduction%20to%20REST.pdf">presentation by Ganes Gunasegaran</a> on a site called sagework, available as a pdf. That presentation does provide one slide defining the pattern as follows.</p>  <ul>   <li>Resource can be read with a GET operation </li>    <li>Resource can be changed only by PUT and DELETE operations </li> </ul>  <p>Now further detective work returns a MindTouch page defining the <a href="http://wiki.developer.mindtouch.com/REST/REST_Patterns/Entity_Pattern"><em>Entity pattern</em></a><em>.<strong> </strong></em>Reading the rest of Ganes’ presentation, it becomes very obvious that the rest of the patterns he presents are just pulled out of the MindTouch REST patterns page. And reading the description of the patterns in the Microsoft document, you will also notice the <strong>exact same definitions</strong>.</p>  <p>We now have a <strong>documented</strong> pattern, within the correct <strong>field of expertise</strong>, aka MindTouch. However, a quick search for the use of this pattern being referenced outside of MindTouch’s web presence returns very little. Furthermore, it doesn’t define the <strong>problem it is designed to solve</strong>. I would question the validity of such a <em>pattern.</em></p>  <p>The proposed fix: again, reference the correct pattern you intended to include to start with, and keep it’s original name. In this specific instance, also make sure that this pattern matches the <strong>definition</strong> of what a pattern is, or redefine and document such a pattern yourself (or get the original authors to do it).</p>  <h5>The entity translator pattern</h5>  <p>This one is defined by <a href="http://msdn.microsoft.com/en-us/library/cc304747.aspx">Microsoft themselves</a>, in the context of web services:</p>  <blockquote>   <p>Implement an entity translator that transforms message data types to business types for requests and reverses the transformation for responses.</p> </blockquote>  <h5>The Facade pattern</h5>  <p>See <a title="http://en.wikipedia.org/wiki/Facade_pattern" href="http://en.wikipedia.org/wiki/Facade_pattern">http://en.wikipedia.org/wiki/Facade_pattern</a>, “A <a href="http://en.wikipedia.org/wiki/Facade">facade</a> is an object that provides a simplified interface to a larger body of code, such as a <a href="http://en.wikipedia.org/wiki/Class_library">class library</a>.” or P&amp;P <em>Pattlets</em> “Provides a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.”</p>  <h5>The Repository pattern</h5>  <p><a href="http://martinfowler.com/eaaCatalog/repository.html">Fowler</a>:&#160; “A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection.”</p>  <h5>Domain Entity pattern</h5>  <p>A google search on <em>Domain Entity Pattern</em> triggers an interesting result, from the same authors as the proposed guidance: <a href="http://www.codeplex.com/AppArch/Wiki/View.aspx?title=Three-tier%20Web%20Application%20Scenario%20(Domain%20Entity)&amp;referringTitle=Home">Three-Tier Web Application Scenario</a>. If you have a look at both, you will see that a lot of recycling between the two guidance documents has happened. Now of course, neither documents match our definition of a <em>design pattern</em>. An obscure page on wikipedia says that domain entities “are a super-set of Data Layer Entities or Data Transfer Objects, and may aggregate zero or more DLEs/DTOs” which I’ll consider compatible with the P&amp;P definition. The naming is however confusing, and not widely in use.</p>  <p>Quick fix: If you want to use the same definition, aka “A set of objects modeled after a domain that represents the relationship between entities in the domain but do not contain behavior or rules related to the entities”, call it what the rest of the world calls them: an <strong>Anemic Data Model</strong>. If you are happy with the anti-pattern but are worried that it may reflect badly on the practices you suggest, call it a <strong>Data Model</strong>. If what you really mean is that it’s a DTO with the same definition as wikipedia, call it a <strong>DTO</strong> and change your definition to match what a DTO is.</p>  <h4>Lets review the guidance</h4>  <p>Now that we’ve cleared out the confusion introduced by the guidance document’s use of patterns, let’s review the various layers and how they relate to REST.</p>  <h5>The lack of context</h5>  <p>The first thing that strikes me is the complete lack of any references to recognized litterature introducing REST. If you’re going to talk about an architecture, just like with a pattern, you *have* to provide the references.</p>  <p>Fix: Introduce REST and <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Roy Fielding’s PhD thesis</a>. Provide links to well-known restafarian web-sites, such as the excellent <a href="http://restpatterns.org">http://restpatterns.org</a> that provides guidance in implementing rest architectures.</p>  <h4></h4>  <h5>The routing</h5>  <p>In a RESTful architecture, everything is mapped as a <strong>Resource</strong>. This is the thing you want to operate upon. Anything can be a resource. For the sake of this entry, let’s imagine that I define a resource as being my computer’s hard drive, the physical hardware equipment that sits inside my laptop’s case.</p>  <p>To be able to operate on a resource, I need to be able to address it. And in REST, I can do so by giving it an identifier. In the case of HTTP, this is a URI. Let’s give a URI to my hard-drive: <a href="http://www.serialseb.com/harddrive/fujitsu">http://www.serialseb.com/harddrive/fujitsu</a>.</p>  <p>If I type the Uri in my browser, said browser will send an http request to my server. The server is now responsible for knowing what the heck it is that I want. This process is called <strong>URI dereferencing</strong>. It’s a big word, but it is what it is and what the common definition is. It’s the <strong>process</strong> by which <strong>a URI</strong> is matched to a <strong>Resource</strong>.</p>  <p>It is assumed that a <strong>handler</strong> will be responsible for doing this dereferencing process. Once the resource has been dereferenced, it is time to do something with it, and this is what an <strong>http method</strong> such as GET or POST does. It defines the <strong>operation</strong> that is to be done against the <strong>Resource</strong>.</p>  <p>We now have the elements to understand what Microsoft talks about when they mention the <strong>Router</strong> idea. In their scenario, the router uses both the <strong>Identifier</strong> and the <strong>Operation</strong> to call some bit of code, commonly referred to as a <strong>handler</strong>. It is a sad fact that Microsoft chooses, in a REST document, to disregard completely the existing and meaningful descriptions of a web operation.</p>  <h5>Resources, representations and the “REST entity”</h5>  <p>Let’s say that I want to add a song I just heard on the radio to my hard-drive. As you probably know, music is heard because the air between the singer’s vocal chords and my tympanic membrane vibrates. This vibration gets turned into an electrical signal and gets processed by my brain to let me make sense of the words that were transported as a vibration. When talking with a human, I would identify the song I just head as “If you seek Amy from Britney Spears”. If I talk with a computer,&#160; I may need to assign it a name too, so let’s do that. <a href="http://www.britneyspears.com/songs/ifyouseekamy">http://www.britneyspears.com/songs/ifyouseekamy</a>.</p>  <p>As far as I know, my hard-drive cannot persist air vibrations to disk. We need a binary stream, because that’s what hard-drives can persist. That binary stream would probably be an mp3 downloaded from a music service. This byte stream is not the song itself (as in the air vibrating), it’s a file in binary format that my computer can process. If the song is a resource, the mp3 file is a <strong>Representation</strong> of that resource.</p>  <p>What this means for my adding that file to my hard drive is that to download the song, I would need an mp3 file. If I <strong>dereference</strong> the URI for the song, I may get a <strong>representation</strong> of this song as an mp3 file. I never transmit the resource itself.</p>  <p>This is why REST is called Representational State Transfer. Now that I have my file, when I want to add it to my hard drive, I could do a POST to <a href="http://www.serialseb.com/harddrive/fujitsu">http://www.serialseb.com/harddrive/fujitsu</a> and include the <strong>Representation</strong> of the song. I have effectively changed the state of my resource (my hard drive, the physical thing) by sending it a representation (the mp3 file).</p>  <p>Microsoft says “In REST a resource is an object that represents a specific state”. As you can probably tell by now, my hard-drive doesn’t <strong>represent</strong> a state, it <strong>has</strong> a state because it is a resource. I <strong>changed</strong> it’s state by sending it a <strong>Representation</strong>. I didn’t sing to my hard-drive to make it persist an mp3.</p>  <p>Quick fix: clear-up the definition to “In REST a resource is a <em>thing</em> that can have state. You can change that state by performing operations on the resources through transferring representations.” You can probably make it more obvious by stipulating that you recommend your business entities to be your resources, acted upon by a representation (your DataContract).</p>  <p>Furthermore, remember that MindTouch’s definition of a <em>REST entity </em>that Microsoft has included is defined <strong>A Resource that gets modified only through PUT and DELETE</strong>.</p>  <p>We’ve seen that a <strong>representation</strong> has by definition no behavior, as it is only a byte stream, and <strong>cannot be operated upon</strong>. Because Microsoft has specified that their use of the word <em>REST Entity</em> is a representation of a resource, it becomes obvious that they have wrongly applied the pattern proposed by MindTouch, which applies to <strong>resources</strong>.</p>  <p>Confusing <strong>resources</strong> and <strong>representations</strong> is a common problem for people new to REST, and one Microsoft has fallen into.</p>  <p>Fix: Drop the Entity (REST) naming. You have misunderstood the original meaning of the pattern. What you are talking about is a <strong>Representation</strong> that you would probably advise to be a DataContract.</p>  <p>Finally, we reach the Entity Translator. Microsoft proposes that such a component “translate[s] between business entities and REST entities exposed by the service”. We’ve now seen that REST entities are in fact <strong>representations</strong>. What is proposed here is a component that can turn a <strong>resource</strong> (aka the business entity) into a <strong>representation</strong> (aka your DataContract).</p>  <p>It is not surprising then that the definition “Resources exposed by the service represent an external contract while business entities are internal to the service” is inaccurate. </p>  <p>Fix: “Resources exposed by the service can only be retrieved and modified through Representations, which represent an external contract”.</p>  <p>And indeed, translators are required to move data from one format (your representation) to another (your business entity as an object living in memory).</p>  <h5>The business layer</h5>  <p>I won’t comment much on the architectural choices of Transaction Scripts and Facades, I have little interest in entering this debate. I will however take note of the definition of the service implementation (which, as we’ve seen, is usually called a <strong>handler</strong>):</p>  <blockquote>   <p>“The service implementation is responsible for translating between external contracts and internal entities and then passing the request on to the business layer façade.”</p> </blockquote>  <p>This seems to indicate that the facade deals with external contracts, but the Entity Translator has already been introduced to deal with such a translation. This seems redundant and is probably a mistake.</p>  <p>Furthermore, if a business facade implements the logic of acting upon a business entity, and the translator maps between datacontracts and business entities, it would seem to me that you’d end up with an anemic service implementation. The only reason I can think of is to map Resource operations to business processes. </p>  <p>While I think such an infrastructure is redundant, here’s a proposed fix: “The service implementation is responsible for mapping operations on resources to business processes in your layer facade.”</p>  <h5>Do we really need Messages?</h5>  <p>I’m very confused by the proposed implementation of the business layer.</p>  <p>REST over http is often considered to be a Resource-Oriented architecture. The first, if not the most fundamental, design issue you will face is modeling your resources well. Like any domain modeling activity, this is not an easy process to get done right.</p>  <p>Provided you have thought of your architecture in terms of exposed resources, you then spend some time defining your representations, aka what goes on the wire. As we’ve seen, that will end up being your DataContract design.</p>  <p>There is a lot of inherent knowledge in resource instances: they have al the information you need to process your request. When I send a POST to <a href="http://www.serialseb.com/harddrives/fujitsu">http://www.serialseb.com/harddrives/fujitsu</a>, the request contains the representation of the file I want to persist, the location in which to persist it. Nothing outside of that operation is required for the processing of the operation to happen.</p>  <p>Why then would one wrap the notion of adding a file onto a hard-drive into a message, pass it to a facade that dispatches the message, to finally get processed by an operation that reads the message to act upon data structures?</p>  <p>Any time you convert between various data structures, you introduce more complexity. Anytime you de-normalize and renormalize, you introduce potential bugs. The proposed solution does the following:</p>  <ol>   <li>Get the request, and transform the datacontract into an instance of the business entity </li>    <li>Encapsulate the business entity into an untyped Message and pass it to a Facade </li>    <li>The facade reads the message to dispatch it to a process </li>    <li>The process opens-up the message to get back to the business entity in the operation and call the entity framework. </li> </ol>  <p>You have achieved absolutely nothing by having a facade. All the data that was required to dispatch the request to a business process was already in the service! You end up with an anemic service that does little if nothing, a business facade that’s not really a facade but a <strong>broker</strong>, and a business process that has to open-up the encapsulation format for no valid reason at all.</p>  <p>As this document is supposed to be a guidance as to best architect a solution, the proposed solution is just not acceptable. Proposing an anemic service is a symptom of a bigger problem: the guidance doesn’t talk at all about resource modeling, and assume that there will be redundant services mapping to the same business process, aka two services doing the same thing.</p>  <p>It looks to me as trying to slap a <strong>message oriented architecture</strong> in which the endpoint receives a message to be processed, on a <strong>resource-oriented</strong> architecture in which the endpoint is the resource on which to apply an operation. The semantics of a resource-oriented architecture eliminate the need for message dispatching.</p>  <p>Proposed fix: Get rid of the business facade as is, and let the service call the business process itself. The message is redundant.</p>  <p>Bad practice: Promote(object[] data) is just bad practice as you’ve now removed any single bit of semantics that were associated with the process.</p>  <h4>Alternative fix</h4>  <p>There is a simple alternative fix that can be applied to the document, by removing the REST references and describing it as a POX architecture.</p>  <h5></h5>  <h5>Conclusion</h5>  <p>I do not know if this guidance is the result of an incomplete understanding of REST architectures (which is quite widespread in Microsoft’s literature) or an attempt at over-simplification.</p>  <p>What I do know is that much needs to be modified before this document can be proposed as a <em>best practice</em> for delivering a RESTful solution. It lacks the proper and accepted terminology, completely bypasses architectural concerns around resource modeling, misrepresent what a REST architecture would look like. It also ignores caching (one of the REST constraints) and proposes an architecture that would make leveraging such caching difficult.</p>  <p>I also call for P&amp;P to involve the communities that have formed around topics such as DDD and REST when they deliver <em>beta</em> versions of their guidance documents. Those errors I’ve highlighted could have been taken care of much earlier in the process, and save me the 5 hours I spent this afternoon writing this blog entry. That this is considered a beta 2 is however completely unacceptable.</p>  <p>Hopefully we will see an updated version of this guidance. If not, hopefully my blog entry will have enough google juice to start fixing the inaccuracies that Microsoft seems to spread about REST way too often.</p>  