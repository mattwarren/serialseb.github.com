---
layout: post
title: HttpUtility.UrlEncode considered harmful
date: '2008-03-17T13:36:00.001Z'

tags: 
modified_time: '2008-03-17T13:36:27.516Z'
blogger_id: tag:blogger.com,1999:blog-4015568221071268916.post-4028571986889369271
blogger_orig_url: http://serialseb.blogspot.com/2008/03/httputilityurlencode-considered-harmful.html
---

<p>An interesting issue was recently raised against my rest framework. The following URI template was used to access a fictional customer:</p>  <p>/customer/{customerName}</p>  <p>When generating an email pointing to this customer, another part of the system was adding the following url:</p>  <p><a href="http://example.org/customer/john+doe">http://example.org/customer/john+doe</a></p>  <p>At this point, my framework returned a 404, even though John Doe exists in our database. So what is happening there? When setting a breakpoint on my CustomerHandler.Get(string customerName) method, customerName ended up with the plus sign present. Why wasn't it converted to a space? Here's some PowerShell code to demonstrate. First, let's create a Uri object and see the result.</p>  <p style="font-size: 13px; background: #012456; font-family: &#39;Consolas&#39;">   <br /><span style="background: black; color: white"></span><span style="color: #eeedf0; background-color: #012456">59&gt; [System.Uri]&quot;http://example.org/folder with space&quot; | select absolutepath, absoluteuri,originalstring | fl     <br />      <br />      <br />AbsolutePath&#160;&#160; : /folder%20with%20space      <br />AbsoluteUri&#160;&#160;&#160; : http://example.org/folder%20with%20space      <br />OriginalString : http://example.org/folder with space      <br />      <br /></span></p>  <p>&#160;</p>  <p>As you can see, the space is encoded with a %20... Now let's see what happens if I call <a href="http://msdn2.microsoft.com/System.Web.HttpUtility.UrlEncode">HttpUtility.UrlEncode</a>.</p>  <p style="font-size: 13px; background: #012456; font-family: &#39;Consolas&#39;">   <br /><span style="background: black; color: white"></span><span style="color: #eeedf0; background-color: #012456">61&gt; [System.Reflection.Assembly]::LoadWithPartialName(&quot;System.Web&quot;) | out-null     <br />62&gt; [System.Web.HttpUtility]::UrlEncode(&quot;folder with space&quot;)      <br />folder+with+space</span></p>  <p>Now the space has been replaced with a plus. Let's review the msdn documentation for the UrlEncode method.</p>  <blockquote>   <p>If characters such as blanks and punctuation are passed in an HTTP stream, they might be misinterpreted at the receiving end. URL encoding converts characters that are not allowed in a URL into character-entity equivalents; URL decoding reverses the encoding. For example, when embedded in a block of text to be transmitted in a URL, the characters &lt; and &gt; are encoded as %3c and %3e.</p> </blockquote>  <p>Obviously the documentation doesn't really described the behaviour that we experience. So is a URL encoding within the scope of the http protocol supposed to have a <strong>+</strong> or a <strong>%20</strong>? Who's right and who's wrong?</p>  <p>Let's travel together along the spec stack we use when dealing with html content, and find out who, between Uri and UrlEncode, is right.</p>  <h4>RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax</h4>  <p>This specification covers URLs in their generalized form, and that's teh specification that defines <em>percent encoding</em> of url, where any reserved character have to be encoded as a percent sign followed by the two-letters hexadecimal representation of the codepoint.</p>  <p>This actually would imply that the correct encoding form of the URL should be <a href="http://example.org/customer/john%20doe">http://example.org/customer/john%20doe</a>.</p>  <p>It also specify that the plus sign is a <em>reserved character</em>, one that can be used by a scheme to delimit <em>stuff</em>. Defining what that stuff is should be the scheme's responsibility. The scheme here is http, so we switch to the next spec in our stack.</p>  <h4>RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1</h4>  <p>This specification, even though it's been written earlier than the lastest URI, does specify some scheme-specific information on how URLs work and what they represent. Going through that specification, HTTP defines some specific behavior for Uri, for example that <a href="http://example.org">http://example.org</a>, <a href="http://example.org:80">http://example.org:80</a> and <a href="http://example.org/">http://example.org/</a> are all equivalent.</p>  <p>The specification also mention the equivalence of the percent encoding we've already seen. Still nothing about the plus sign. Which leads us to the third specification that's involved here.</p>  <h4>W3C Recommendation: HTML 4.01</h4>  <p><em>Note that I ignore the XHTML 1.0 specification as it is mostly only a reformulation of the html 4 specification in an xml format.</em></p>  <p>The HTML specification reminds the reader of URIs and how they work. There are two interesting bits in the specification. The first one, entitled <a href="http://www.w3.org/TR/html401/appendix/notes.html#non-ascii-chars">non-ascii characters in URI attribute</a> values, defines once again the percent encoding scheme. Still no trace of that plus sign.</p>  <p>And then you discover the gem of the <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1">application/x-www-form-urlencoded</a> content type. In it, we find the usual url encoding, with the addition of the <strong>space being encoded as a plus</strong>.</p>  <p>Interestingly enough, this format is only to be used when attaching content within a POST http request, and has nothing to do with URL encoding, except for the similarity of writing key=value&amp;key2=othervalue to encode named values.</p>  <h4>Conclusion</h4>  <p>So there you have it. The content-type used by html to send form content is an html specific content sent as the payload to a post http request. It has no bearing and no compatibility with either http or URLs. If you generate or consume URLs, the plus sign should be opaque.</p>  <p>In other words, stay welll away from HttpUtility.UrlEncode.</p>  