---
layout: post
title: Multiple views in OpenRasta, and delving into the pipeline
date: '2009-03-21T01:22:00.002Z'

tags: 
modified_time: '2009-06-09T01:07:02.940+01:00'
blogger_id: tag:blogger.com,1999:blog-4015568221071268916.post-7984579911184835649
comments: true
blogger_orig_url: http://serialseb.blogspot.com/2009/03/multiple-views-in-openrasta-and-delving.html
---

<p><b>This entry may be outdated. For the latest updates on openrasta, see <a href="http://www.openrasta.com">www.openrasta.com</a>.</b></p>
<p>I just had an idea to clean-up my resource definitions. I could’ve gone straight in the OpenRasta code and add just this small additional feature I really want, but OpenRasta is all about extensibility and composition, and I’m a few days away from the beta 1 release. So I thought I’d put to test the API from the outside, and tell you a story about how to define multiple views on a resource with the WebForms Codec. I may move this entry over to the documentation part of the project later on.</p>  <p>--</p>  <p>In OpenRasta, you need to define your resources individually. A resource in OpenRasta is simply a class you create that handlers will deal with. Each resource may have any number of URIs, and any numbers of codecs. A codec is a piece of code responsible for rendering a codec, and on this project I use the WebForms codec.</p>  <div style="padding-right: 10px; padding-left: 10px; font-size: 10pt; background: #252525; float: right; padding-bottom: 10px; color: #e0e0e0; padding-top: 10px; font-family: consolas, courier new">   <p style="margin: 0px"><span style="color: #00d2d2">ResourceSpace</span><span style="color: #a6a0e0">.</span>Has<span style="color: #a6a0e0">.</span>ResourcesOfType<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">UserRegistration</span><span style="color: #a6a0e0">&gt;</span>()</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #a6a0e0">.</span>AtUri(<span style="color: #fa8072">&quot;/registration&quot;</span>)</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #a6a0e0">.</span>HandledBy<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">UserHandler</span><span style="color: #a6a0e0">&gt;</span>()</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #a6a0e0">.</span>AndRendededByAspx(<span style="color: #fa8072">&quot;~/Views/User/New.aspx&quot;</span>);</p> </div>  <p>You can see here the registration for my UserRegistration resource. It defines where to find it, what handler is using it, and a page to render it.</p>  <p>Whenever a user has successfully registered, it’s quite usual to return them to a page welcoming them to the world of splendor that you’ll provide them, now that you have all their previous personal details. And it usually contains the exact same information that you collected previously. And that’s where it can become a bit hairy.</p>  <p>The initial (and in many scenario sane) reaction is to create a separate resource / handler / view couple to render our Thanks page. This is indeed accurate: the thing that I serve to the client is indeed a document with a “Thank you” message, complete with blink tags.</p>  <p>Another point of view, and the one I usually favour, is to consider those various elements as different views on the same resource. From a ReST point of view, each of those views will be a resource in its own right, but from a programming perspective OpenRasta will treat them as being the same entity to operate against.</p>  <p>So how do we solve the conundrum? The first piece of the puzzle is to use the capacity baked in the WebForms view engine to define multiple views. We can change the registration ever-so-slightly by using the generic notation for registering the view.</p>  <div style="padding-right: 5px; padding-left: 5px; font-size: 10pt; background: #252525; float: left; padding-bottom: 5px; margin: 0px 5px; color: #e0e0e0; padding-top: 5px; font-family: consolas, courier new">   <p style="margin: 0px"><span style="color: #00d2d2">ResourceSpace</span><span style="color: #a6a0e0">.</span>Has<span style="color: #a6a0e0">.</span>ResourcesOfType<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">UserRegistration</span><span style="color: #a6a0e0">&gt;</span>()</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #a6a0e0">.</span>AtUri(<span style="color: #fa8072">&quot;/registration&quot;</span>)</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #a6a0e0">.</span>HandledBy<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">UserHandler</span><span style="color: #a6a0e0">&gt;</span>()</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #a6a0e0">.</span>AndTranscodedBy<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">WebFormsCodec</span><span style="color: #a6a0e0">&gt;</span>(<span style="color: #00bfff">new</span></p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; index <span style="color: #a6a0e0">=</span> <span style="color: #fa8072">&quot;~/Views/User/New.aspx&quot;</span>,</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; thanks<span style="color: #a6a0e0">=</span> <span style="color: #fa8072">&quot;~/Views/User/Thanks.aspx&quot;</span></p>    <p style="margin: 0px">&#160;&#160;&#160; });</p> </div>  <p>The registration looks very similar. The <em>AndRenderedByAspx</em> method you saw earlier is a shorthand for the full notation using the <em>AndTranscodedBy&lt;T&gt;</em> which lets you plug-in many different codecs per-resource.</p>  <p>The anonymous type itself defines view names that will be passed to the WebForms codec. The question is, how do we get the framework to choose those views?</p>  <p>By default, that codec always uses a view named <em>index </em>(or <em>default </em>or <em>get</em>) for the default view to select. Another approach is to use uri path segments. If I typed the URI <a href="http://localhost/registration;thanks">http://localhost/registration;<strong>thanks</strong></a> the thanks bit is called a path segment, and is always separated by a semi-column. If you go and try that now on your OpenRasta website, it won’t work (something about not enabling features don’t want). You need to go and enable it by adding a UriDecorator.</p>  <div style="padding-right: 5px; padding-left: 5px; font-size: 10pt; background: #252525; padding-bottom: 5px; margin: 0px 5px; color: #e0e0e0; padding-top: 5px; font-family: consolas, courier new">   <p style="margin: 0px"><span style="color: #00d2d2">ResourceSpace</span><span style="color: #a6a0e0">.</span>Has<span style="color: #a6a0e0">.</span>UriDecorator<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">PathSegmentAsRendererUriDecorator</span><span style="color: #a6a0e0">&gt;</span>();</p> </div>  <p>URI decorators in OpenRasta are modules that lets you manipulate uris before a request is processed. It’s used for integrating various features, such as file extensions, localized URIs, and whatever else you may think of.&#160; And the reason the PathSegmentAsRenderer is called the way it is is historical, and before this blog entry I never realized that it should really be updated to PathSegmentAsCodecParameter. Expect to see that change in the trunk over the weekend. (Codecs used to be called Renderers when I was working on the codebase that preceded OpenRasta).</p>  <p>So, all is good, we can now go to /registration;thanks and see the Thanks.aspx page rendering a resource. But what if you didn’t want to use path segments, and define two different URIs yourself?</p>  <div style="padding-right: 5px; padding-left: 5px; font-size: 10pt; background: #252525; float: right; padding-bottom: 5px; margin: 0px 5px; color: #e0e0e0; padding-top: 5px; font-family: consolas, courier new">   <p style="margin: 0px"><span style="color: #a6a0e0">.</span>AtUri(<span style="color: #fa8072">&quot;/registration&quot;</span>)</p>    <p style="margin: 0px"><span style="color: #a6a0e0">.</span>AndAt(<span style="color: #fa8072">&quot;/registration/{emailAddress}/complete&quot;</span>)<span style="color: #a6a0e0">.</span>Named(<span style="color: #fa8072">&quot;thanks&quot;</span>)</p>    <p style="margin: 0px"><span style="color: #a6a0e0">.</span>HandledBy<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">UserHandler</span><span style="color: #a6a0e0">&gt;</span>()</p>    <p style="margin: 0px"><span style="color: #a6a0e0">.</span>AndTranscodedBy<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">WebFormsCodec</span><span style="color: #a6a0e0">&gt;</span>(<span style="color: #00bfff">new</span></p>    <p style="margin: 0px">{</p>    <p style="margin: 0px">&#160;&#160;&#160; index <span style="color: #a6a0e0">=</span> <span style="color: #fa8072">&quot;~/Views/User/New.aspx&quot;</span>,</p>    <p style="margin: 0px">&#160;&#160;&#160; thanks<span style="color: #a6a0e0">=</span> <span style="color: #fa8072">&quot;~/Views/User/Thanks.aspx&quot;</span></p>    <p style="margin: 0px">});</p> </div>  <p>We’re going to need to leverage a few other features of the configuration API.</p>  <p>First is the support for named URIs. If one resource can have multiple name, that feature lets you give it a friendly name. It is mostly used to decorate a handler method to help select which overload of a method gets executed, but it can also serve our purpose here quite well.</p>  <p>We’re going to plug in the OpenRasta pipeline, and do the same thing the PathSegmentAsRendererUriDecorator type does: add a string that will be sent to the codec to help it choose. To do this, we’re going to implement a class implementing IPipelineContributor. You can find the code at the end, as an example.</p>  <p>This exposes a few specificities of OpenRasta. The first one is the pipeline model itself. Whenever you want to integrate deep within the framework, and modify the way things are processed, you need to tell OpenRasta which components you depend on in the execution pipeline. That’s what the <em>ExecuteBefore</em> and <em>ExecuteAfter</em> methods do. Out of the box, there’s 18 contributos to choose from. Each component does a tiny bit of the request processing, and enrich the data until it’s been turned back into a byte stream. The execution order is non-deterministic: OpenRasta will always honour your requests to be before or after someone else, but doesn’t guarantee anything beyond that.</p>  <p>Another aspect is the fact that pipeline contributors are the only components in the system to be singletons. They will be loaded one and never be discarded. That’s why they take a dependency on the ICommunicationContext god object. It’s the only ever Context object you’ll find in OpenRasta. Most of the interfaces in the system have flat methods with a well-known number of parameters. Just the minimum amount of information needed for a component to execute, everything else is handled by dependency injection.</p>  <p>Overall, when you’re an IPipelineContributor in OpenRasta, your’re like god, you run at the kernel of stuff. And because it’s a pipeline model, any of your actions *will* have consequences on everyone else. There’s many other less low-level extensibility points in OpenRasta, so when you can, use them!</p>  <p><em>The code</em></p>  <div style="padding-right: 5px; padding-left: 5px; font-size: 10pt; background: #252525; padding-bottom: 5px; margin: 0px 5px; color: #e0e0e0; padding-top: 5px; font-family: consolas, courier new">   <p style="margin: 0px"><span style="color: #00bfff">public</span> <span style="color: #00bfff">class</span> <span style="color: #00d2d2">UriNameAsCodecParameter</span> : <span style="color: #92e4d6">IPipelineContributor</span></p>    <p style="margin: 0px">{</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #00bfff">public</span> <span style="color: #00bfff">void</span> Initialize(<span style="color: #92e4d6">IPipeline</span> pipelineRunner)</p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; pipelineRunner<span style="color: #a6a0e0">.</span>ExecuteBefore<span style="color: #a6a0e0">&lt;</span><span style="color: #00d2d2">ResponseEntityWriter</span><span style="color: #a6a0e0">&gt;</span>(AddUriNameToCodecParameters);</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #00bfff">public</span> <span style="color: #00d2d2">PipelineContinuation</span> AddUriNameToCodecParameters(<span style="color: #92e4d6">ICommunicationContext</span> context)</p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #00bfff">if</span> (context<span style="color: #a6a0e0">.</span>PipelineData<span style="color: #a6a0e0">.</span>SelectedResource<span style="color: #a6a0e0">.</span>UriName <span style="color: #a6a0e0">!=</span> <span style="color: #00bfff">null</span>)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #00bfff">var</span> newCodecParameters <span style="color: #a6a0e0">=</span> <span style="color: #00bfff">new</span> <span style="color: #00d2d2">List</span><span style="color: #a6a0e0">&lt;</span><span style="color: #00bfff">string</span><span style="color: #a6a0e0">&gt;</span> { context<span style="color: #a6a0e0">.</span>PipelineData<span style="color: #a6a0e0">.</span>SelectedResource<span style="color: #a6a0e0">.</span>UriName };</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #00bfff">if</span> (context<span style="color: #a6a0e0">.</span>Request<span style="color: #a6a0e0">.</span>CodecUriParameters <span style="color: #a6a0e0">!=</span> <span style="color: #00bfff">null</span>)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; newCodecParameters<span style="color: #a6a0e0">.</span>AddRange(context<span style="color: #a6a0e0">.</span>Request<span style="color: #a6a0e0">.</span>CodecUriParameters);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; context<span style="color: #a6a0e0">.</span>Request<span style="color: #a6a0e0">.</span>CodecUriParameters <span style="color: #a6a0e0">=</span> newCodecParameters<span style="color: #a6a0e0">.</span>ToArray();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #00bfff">return</span> <span style="color: #00d2d2">PipelineContinuation</span><span style="color: #a6a0e0">.</span>Continue;</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p>    <p style="margin: 0px">}</p> </div>  <p></p>  <p><em>The registration (until I’ve revisited that part of the code, cause I sure don’t like it. It’s an outstanding task)</em></p>  <div style="padding-right: 5px; padding-left: 5px; font-size: 10pt; background: #252525; padding-bottom: 5px; margin: 0px 5px; color: #e0e0e0; padding-top: 5px; font-family: consolas, courier new">   <p style="margin: 0px"><span style="color: #00d2d2">DependencyManager</span><span style="color: #a6a0e0">.</span>GetService<span style="color: #a6a0e0">&lt;</span><span style="color: #92e4d6">ITypeRepository</span><span style="color: #a6a0e0">&lt;</span><span style="color: #92e4d6">IPipelineContributor</span><span style="color: #a6a0e0">&gt;&gt;</span>()<span style="color: #a6a0e0">.</span>Types<span style="color: #a6a0e0">.</span>Add(<span style="color: #00bfff">typeof</span>(<span style="color: #00d2d2">UriNameAsCodecParameter</span>));</p> </div>