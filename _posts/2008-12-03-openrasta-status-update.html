---
layout: post
title: OpenRasta status update
date: '2008-12-03T04:28:00.002Z'

tags: 
modified_time: '2009-06-09T01:07:23.532+01:00'
blogger_id: tag:blogger.com,1999:blog-4015568221071268916.post-154423854113172978
blogger_orig_url: http://serialseb.blogspot.com/2008/12/openrasta-status-update.html
---

<p><b>This entry may be outdated. For the latest updates on openrasta, see <a href="www.openrasta.com">www.openrasta.com</a>.</b></p>
<p>I’ll be adding the proper headers tomorrow and release this version. It’s getting to a point where it can start marching to beta status openly. Here’s the change log since the last status update.</p>  <h4>IO</h4>  <ul>   <li>new stream chain infrastructure for accurate content length discovery     <br />Codecs don’t have to deal with knowing the content-length anymore, it’s all done by wrapping the stream with one that tracks the Content-Length accurately.</li>    <li>Multipart support     <br />Support is in, and for the most part there is no more issues with asp.net taking over. The next step is to completely bypass asp.net and use the IHttpWorkerRequest directly. There’s preliminary support for that, but I want to have a clean-cut separation between streamed and buffered modes, which means implementing bulk transfer. Support is only buffered at the moment.      <br />At the IO level, you’ll find the goods in BoundaryStreamReader and BoundaryStreamWriter, as well as the new HistoryStream class. The problem with potentially non-seekable streams when reading boundaries is that you may read past the end of the boundary and need to go back… But It’s not seekable! HistoryStream keeps a fixed buffer of the last couple of reads and let you seek within that.      <br />One level up, the MultipartReader and MultipartWriter classes are the ones able to give you IHttpEntity objects from / to your streams.</li> </ul>  <h4>Configuration</h4>  <h4></h4>  <ul>   <li>new configuration syntax     <br />Everything is now on ResourceSpace. I didn’t like the focus on URIs the previous versions had. Furthermore, they’re all attached to an IHas singleton, so you can add your own configuration language from the top-level ResourceSpace.Has.new demo site      <br />This should hopefully be used in the future to run some Watin automated tests.</li>    <li>Configuration auto-wireup     <br />You can either do the configuration in your global.asax or use a class at the root of your app. You used to need IRastaConfiguration (how confusing), it’s now called IConfigurationSource</li> </ul>  <h4>Infrastructure</h4>  <ul>   <li>new dependency resolver flow     <br />No more direct access to the IDependencyResolver. The framework treats the internal one and any external one you may want to use (aka your favourite container) equally. Fixed a bunch of bugs when registering singleton instances in the internal container.</li>    <li>Error infrastructure     <br />The pipeline has been modified to be able to go back and restart the processing. That means that your error page will be subject to content-type negotiation.</li>    <li>Resource matching     <br />By default, resource instances you return from your handlers are seeked as an exact match you registered. There’s an opt-out by registering a resource as AnyChildOf&lt;Customer&gt;, which will then match Customer and any class inheriting from it. Feedback welcome.</li> </ul>  <h4>Refactoring</h4>  <ul>   <li>Heavy renaming     <br />Folders now have the proper names, there should not be anything left with the Rasta moniker. Lot of interfaces and classes have been updated to reflect the http spec a bit better (IHttpEntity, IHttpMessage…) or to be more meaningful (ICommunicationContext replaces IRastaContext, IRequest and IResponse are shorter than the previous interface names). All the asp.net specific implementations have been renamed to AspNetXxx.</li>    <li>Http handlers and modules     <br />The http handler is now OpenRastaHandler. It may be changed to optimize the code path for IIS7 integrated mode when available. The module is now OpenRastaModule.</li> </ul>  <h4>Bug fixes</h4>  <ul>   <li>Integration tests     <br />Just fixed the infrastrucutre to copy web.config automatically to the correct folder. The default destination is now in a separate folder. Other projects will follow soon.</li>    <li>Removing god objects     <br />RastaConfiguration used to be a big mammoth with way too much happening on it. It’s been split between DependencyManager (a service locator for the few repositories being used) and OpenRastaConfiguration (that exposes only the Manual property).      <br />All the same, IRequest and IResponse are much leaner than they used to be, with all the implementation details moved to the PipelineData object. TODO: Auto-register IRequest and IResponse in the container so you don’t need the dependency on ICommunicationContext.</li> </ul>  <h4>Codecs</h4>  <ul>   <li>Content negotiation and media types     <br />I thought I had this one fairly nailed-out, turned-out I was wrong. The mime types are now prioritized on the server, so that when the client asks for */* (&lt;cough&gt;IE&lt;cough&gt;), the mime type with the highest quality is selected. Reprioritized both the webforms codec and the html error page codec to prefer text/html over application/xhtml+xml.      <br />HttpContentType is now called MediaType, which should solve the confusion between the ContentType header and what a media type is.      <br />TODO: Write the tests to ensure the Vary header is appended correctly.      <br />TODO: Have a way for the codec to get involved during the selection of the correct mime type. This would let the webforms engine detect the doctype and set the content-type appropriately.</li>    <li>Error codes     <br />There’s some new properties on OperationResult to detect client and server errors. This is used to automatically pad the returned representation, as IE (again) hides anything returned with a size less than 512 bytes.</li> </ul>  <h4>Webforms engine</h4>  <ul>   <li>Webforms url rewriting     <br />I’ve now re-enabled the capability to register a webforms page at a fixed Uri with new extension methods, associated with a behind-the-scene handler and some changes to the codec.</li>    <li>Markup     <br />I’ve started refactoring the extension methods used for generating html content, which you’ll find in OpenRasta.Markup. There should be much more tomorrow.</li>    <li>Uri creation     <br />IUriResolver has been simplified, and a lot of noise implementation is now done with extension methods. Also a work in progress so expect more unit tests in the next few days. And you can now automatically generate URIs from any object by using <em>myCustomer.CreateUri();</em> Sweet.</li>    <li>Plain text codec     <br />I thought it was more than time to bring plain-text back on the scene. So now you have a text/plain codec out of the box.</li>    <li>Silverlight     <br />Work on this is suspended for now until we reach beta 1.</li> </ul>  <h4>What’s missing</h4>  <ul>   <li>For both the MultipartFormDataCodec and the ApplicationXWwwUrlFormEncodedCodec, we still haven’t gained back the support for complex types. This is coming back tomorrow, with a common code-base. That should be the end of ReflectionHelper, as the code gets migrated (and unit-tested).</li>    <li>The license header files, which will also be there tomorrow. Once it’s done I’ll give the svn and trac addresses, and open the mailing list to the public :)</li> </ul>  <p>There you go, there’s probably a lot missing as I didn’t log everything in svn, but we’re approaching the end of the tunnel. Aim is to be feature-complete for beta 1 in a month time. Patches are welcome :)</p>